const sendButton = document.getElementById('send-button');
const userInput = document.getElementById('user-input');
const chatMessages = document.getElementById('chat-messages');
const typingIndicator = document.getElementById('typing-indicator');
const chatList = document.getElementById('chat-list'); // assume you add a container for chat sessions

let chats = JSON.parse(localStorage.getItem('chats')) || [];
let currentChatId = null;

// Initialize
function init() {
  if (chats.length === 0) {
    createNewChat();
  } else {
    currentChatId = chats[0].id;
  }
  renderChatList();
  renderCurrentChat();
}
init();

// Create new chat session with autogenerated name + id
function createNewChat() {
  const id = Date.now().toString();
  const newChat = {
    id,
    name: `Chat ${chats.length + 1}`,
    messages: []
  };
  chats.unshift(newChat);
  currentChatId = id;
  saveChats();
  renderChatList();
  renderCurrentChat();
}

// Save chats array to localStorage
function saveChats() {
  localStorage.setItem('chats', JSON.stringify(chats));
}

// Render chat list sidebar
function renderChatList() {
  if (!chatList) return; // no sidebar container
  chatList.innerHTML = '';
  chats.forEach(chat => {
    const chatItem = document.createElement('div');
    chatItem.textContent = chat.name;
    chatItem.classList.add('chat-item');
    if (chat.id === currentChatId) chatItem.classList.add('active');
    chatItem.onclick = () => {
      currentChatId = chat.id;
      renderCurrentChat();
      renderChatList();
    };
    chatList.appendChild(chatItem);
  });
}

// Render messages of current chat in chatMessages container
function renderCurrentChat() {
  chatMessages.innerHTML = '';
  const chat = chats.find(c => c.id === currentChatId);
  if (!chat) return;
  chat.messages.forEach(({ text, isUser }) => {
    appendMessage(text, isUser, false); // false = donâ€™t save again
  });
  chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
}

// Append message both visually and in memory (unless skipSave is true)
function appendMessage(text, isUser, skipSave = false) {
  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message');
  msgDiv.classList.add(isUser ? 'user-message' : 'assistant-message');
  const p = document.createElement('p');
  msgDiv.appendChild(p);
  chatMessages.appendChild(msgDiv);
  chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });

  if (!skipSave) {
    const chat = chats.find(c => c.id === currentChatId);
    if (chat) {
      chat.messages.push({ text, isUser });
      saveChats();
    }
  }

  if (isUser) {
    p.textContent = text;
    msgDiv.classList.add('drift');
  } else {
    typeText(p, text, msgDiv);
  }
}

async function typeText(element, text, container) {
  element.textContent = '';
  container.classList.add('shaking');
  for (let i = 0; i < text.length; i++) {
    element.textContent += text.charAt(i);
    await new Promise((r) => setTimeout(r, 18));
  }
  container.classList.remove('shaking');
  container.classList.add('drift');
}

// Your original sendMessage exactly, but also stores messages in current chat memory
async function sendMessage() {
  const input = userInput.value.trim();
  if (!input) return;
  appendMessage(input, true);
  userInput.value = '';
  typingIndicator.style.display = 'block';

  try {
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ messages: [{ role: 'user', content: input }] })
    });
    const data = await response.json();
    typingIndicator.style.display = 'none';
    appendMessage(data.response || 'Error: No response', false);
  } catch (err) {
    typingIndicator.style.display = 'none';
    appendMessage('Error: Load failed', false);
  }
}

// Add new chat button (optional, call this on a button click)
function addNewChat() {
  createNewChat();
}